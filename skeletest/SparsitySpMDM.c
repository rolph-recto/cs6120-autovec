// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// taco "C(i,j) = A(i, k) * B(k, j) " -write-source=SparsitySpMDM.c
#ifndef TACO_C_HEADERS
#define TACO_C_HEADERS
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include <complex.h>
#include <string.h>
#define TACO_MIN(_a,_b) ((_a) < (_b) ? (_a) : (_b))
#define TACO_MAX(_a,_b) ((_a) > (_b) ? (_a) : (_b))
#define TACO_DEREF(_a) (((___context___*)(*__ctx__))->_a)
#ifndef TACO_TENSOR_T_DEFINED
#define TACO_TENSOR_T_DEFINED
typedef enum { taco_mode_dense, taco_mode_sparse } taco_mode_t;
typedef struct {
  int32_t      order;         // tensor order (number of modes)
  int32_t*     dimensions;    // tensor dimensions
  int32_t      csize;         // component size
  int32_t*     mode_ordering; // mode storage ordering
  taco_mode_t* mode_types;    // mode storage types
  uint8_t***   indices;       // tensor index data (per mode)
  uint8_t*     vals;          // tensor values
  int32_t      vals_size;     // values array size
} taco_tensor_t;
#endif
int cmp(const void *a, const void *b) {
  return *((const int*)a) - *((const int*)b);
}
#endif

int compute(taco_tensor_t *C, taco_tensor_t *A, taco_tensor_t *B) {
  int C1_dimension = (int)(C->dimensions[0]);
  int C2_dimension = (int)(C->dimensions[1]);
  double* restrict C_vals = (double*)(C->vals);
  int A1_dimension = (int)(A->dimensions[0]);
  int A2_dimension = (int)(A->dimensions[1]);
  double* restrict A_vals = (double*)(A->vals);
  int B1_dimension = (int)(B->dimensions[0]);
  int B2_dimension = (int)(B->dimensions[1]);
  double* restrict B_vals = (double*)(B->vals);

  #pragma omp parallel for schedule(static)
  for (int32_t pC = 0; pC < (C1_dimension * C2_dimension); pC++) {
    C_vals[pC] = 0.0;
  }

  #pragma omp parallel for schedule(runtime)
  for (int32_t i = 0; i < A1_dimension; i++) {
    for (int32_t k = 0; k < B1_dimension; k++) {
      int32_t pA2 = i * A2_dimension + k;
      for (int32_t j = 0; j < B2_dimension; j++) {
        int32_t pC2 = i * C2_dimension + j;
        int32_t pB2 = k * B2_dimension + j;
        C_vals[pC2] = C_vals[pC2] + A_vals[pA2] * B_vals[pB2];
      }
    }
  }
  return 0;
}

int assemble(taco_tensor_t *C, taco_tensor_t *A, taco_tensor_t *B) {
  int C1_dimension = (int)(C->dimensions[0]);
  int C2_dimension = (int)(C->dimensions[1]);
  double* restrict C_vals = (double*)(C->vals);

  C_vals = (double*)malloc(sizeof(double) * (C1_dimension * C2_dimension));

  C->vals = (uint8_t*)C_vals;
  return 0;
}

int evaluate(taco_tensor_t *C, taco_tensor_t *A, taco_tensor_t *B) {
  int C1_dimension = (int)(C->dimensions[0]);
  int C2_dimension = (int)(C->dimensions[1]);
  double* restrict C_vals = (double*)(C->vals);
  int A1_dimension = (int)(A->dimensions[0]);
  int A2_dimension = (int)(A->dimensions[1]);
  double* restrict A_vals = (double*)(A->vals);
  int B1_dimension = (int)(B->dimensions[0]);
  int B2_dimension = (int)(B->dimensions[1]);
  double* restrict B_vals = (double*)(B->vals);

  int32_t C_capacity = C1_dimension * C2_dimension;
  C_vals = (double*)malloc(sizeof(double) * C_capacity);

  #pragma omp parallel for schedule(static)
  for (int32_t pC = 0; pC < C_capacity; pC++) {
    C_vals[pC] = 0.0;
  }

  #pragma omp parallel for schedule(runtime)
  for (int32_t i = 0; i < A1_dimension; i++) {
    for (int32_t k = 0; k < B1_dimension; k++) {
      int32_t pA2 = i * A2_dimension + k;
      for (int32_t j = 0; j < B2_dimension; j++) {
        int32_t pC2 = i * C2_dimension + j;
        int32_t pB2 = k * B2_dimension + j;
        C_vals[pC2] = C_vals[pC2] + A_vals[pA2] * B_vals[pB2];
      }
    }
  }

  C->vals = (uint8_t*)C_vals;
  return 0;
}
